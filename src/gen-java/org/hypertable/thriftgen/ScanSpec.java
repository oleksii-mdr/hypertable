/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.hypertable.thriftgen;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Specifies options for a scan
 * 
 * <dl>
 *   <dt>row_intervals</dt>
 *   <dd>A list of ranges of rows to scan. Mutually exclusive with
 *   cell_interval</dd>
 * 
 *   <dt>cell_intervals</dt>
 *   <dd>A list of ranges of cells to scan. Mutually exclusive with
 *   row_intervals</dd>
 * 
 *   <dt>return_deletes</dt>
 *   <dd>Indicates whether cells pending delete are returned</dd>
 * 
 *   <dt>revs</dt>
 *   <dd>Specifies max number of revisions of cells to return</dd>
 * 
 *   <dt>row_limit</dt>
 *   <dd>Specifies max number of rows to return</dd>
 * 
 *   <dt>start_time</dt>
 *   <dd>Specifies start time in nanoseconds since epoch for cells to
 *   return</dd>
 * 
 *   <dt>end_time</dt>
 *   <dd>Specifies end time in nanoseconds since epoch for cells to return</dd>
 * 
 *   <dt>columns</dt>
 *   <dd>Specifies the names of the columns to return</dd>
 * 
 *   <dt>cell_limit</dt>
 *   <dd>Specifies max number of cells to return</dd>
 * 
 *   <dt>cell_limit_per_family</dt>
 *   <dd>Specifies max number of cells to return per column family</dd>
 * 
 *   <dt>row_regexp</dt>
 *   <dd>Specifies a regexp used to filter by rowkey</dd>
 * 
 *   <dt>value_regexp</dt>
 *   <dd>Specifies a regexp used to filter by cell value</dd>
 * 
 *   <dt>scan_and_filter_rows</dt>
 *   <dd>Indicates whether table scan filters the rows specified instead of individual look up</dd>
 * 
 *   <dt>row_offset</dt>
 *   <dd>Specifies number of rows to be skipped</dd>
 * 
 *   <dt>cell_offset</dt>
 *   <dd>Specifies number of cells to be skipped</dd>
 * </dl>
 */
public class ScanSpec implements org.apache.thrift.TBase<ScanSpec, ScanSpec._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("ScanSpec");

  private static final org.apache.thrift.protocol.TField ROW_INTERVALS_FIELD_DESC = new org.apache.thrift.protocol.TField("row_intervals", org.apache.thrift.protocol.TType.LIST, (short)1);
  private static final org.apache.thrift.protocol.TField CELL_INTERVALS_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_intervals", org.apache.thrift.protocol.TType.LIST, (short)2);
  private static final org.apache.thrift.protocol.TField RETURN_DELETES_FIELD_DESC = new org.apache.thrift.protocol.TField("return_deletes", org.apache.thrift.protocol.TType.BOOL, (short)3);
  private static final org.apache.thrift.protocol.TField VERSIONS_FIELD_DESC = new org.apache.thrift.protocol.TField("versions", org.apache.thrift.protocol.TType.I32, (short)4);
  private static final org.apache.thrift.protocol.TField ROW_LIMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("row_limit", org.apache.thrift.protocol.TType.I32, (short)5);
  private static final org.apache.thrift.protocol.TField START_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("start_time", org.apache.thrift.protocol.TType.I64, (short)6);
  private static final org.apache.thrift.protocol.TField END_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("end_time", org.apache.thrift.protocol.TType.I64, (short)7);
  private static final org.apache.thrift.protocol.TField COLUMNS_FIELD_DESC = new org.apache.thrift.protocol.TField("columns", org.apache.thrift.protocol.TType.LIST, (short)8);
  private static final org.apache.thrift.protocol.TField KEYS_ONLY_FIELD_DESC = new org.apache.thrift.protocol.TField("keys_only", org.apache.thrift.protocol.TType.BOOL, (short)9);
  private static final org.apache.thrift.protocol.TField CELL_LIMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_limit", org.apache.thrift.protocol.TType.I32, (short)14);
  private static final org.apache.thrift.protocol.TField CELL_LIMIT_PER_FAMILY_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_limit_per_family", org.apache.thrift.protocol.TType.I32, (short)10);
  private static final org.apache.thrift.protocol.TField ROW_REGEXP_FIELD_DESC = new org.apache.thrift.protocol.TField("row_regexp", org.apache.thrift.protocol.TType.STRING, (short)11);
  private static final org.apache.thrift.protocol.TField VALUE_REGEXP_FIELD_DESC = new org.apache.thrift.protocol.TField("value_regexp", org.apache.thrift.protocol.TType.STRING, (short)12);
  private static final org.apache.thrift.protocol.TField SCAN_AND_FILTER_ROWS_FIELD_DESC = new org.apache.thrift.protocol.TField("scan_and_filter_rows", org.apache.thrift.protocol.TType.BOOL, (short)13);
  private static final org.apache.thrift.protocol.TField ROW_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("row_offset", org.apache.thrift.protocol.TType.I32, (short)15);
  private static final org.apache.thrift.protocol.TField CELL_OFFSET_FIELD_DESC = new org.apache.thrift.protocol.TField("cell_offset", org.apache.thrift.protocol.TType.I32, (short)16);
  private static final org.apache.thrift.protocol.TField COLUMN_PREDICATES_FIELD_DESC = new org.apache.thrift.protocol.TField("column_predicates", org.apache.thrift.protocol.TType.LIST, (short)17);

  public List<RowInterval> row_intervals; // required
  public List<CellInterval> cell_intervals; // required
  public boolean return_deletes; // required
  public int versions; // required
  public int row_limit; // required
  public long start_time; // required
  public long end_time; // required
  public List<String> columns; // required
  public boolean keys_only; // required
  public int cell_limit; // required
  public int cell_limit_per_family; // required
  public String row_regexp; // required
  public String value_regexp; // required
  public boolean scan_and_filter_rows; // required
  public int row_offset; // required
  public int cell_offset; // required
  public List<ColumnPredicate> column_predicates; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    ROW_INTERVALS((short)1, "row_intervals"),
    CELL_INTERVALS((short)2, "cell_intervals"),
    RETURN_DELETES((short)3, "return_deletes"),
    VERSIONS((short)4, "versions"),
    ROW_LIMIT((short)5, "row_limit"),
    START_TIME((short)6, "start_time"),
    END_TIME((short)7, "end_time"),
    COLUMNS((short)8, "columns"),
    KEYS_ONLY((short)9, "keys_only"),
    CELL_LIMIT((short)14, "cell_limit"),
    CELL_LIMIT_PER_FAMILY((short)10, "cell_limit_per_family"),
    ROW_REGEXP((short)11, "row_regexp"),
    VALUE_REGEXP((short)12, "value_regexp"),
    SCAN_AND_FILTER_ROWS((short)13, "scan_and_filter_rows"),
    ROW_OFFSET((short)15, "row_offset"),
    CELL_OFFSET((short)16, "cell_offset"),
    COLUMN_PREDICATES((short)17, "column_predicates");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // ROW_INTERVALS
          return ROW_INTERVALS;
        case 2: // CELL_INTERVALS
          return CELL_INTERVALS;
        case 3: // RETURN_DELETES
          return RETURN_DELETES;
        case 4: // VERSIONS
          return VERSIONS;
        case 5: // ROW_LIMIT
          return ROW_LIMIT;
        case 6: // START_TIME
          return START_TIME;
        case 7: // END_TIME
          return END_TIME;
        case 8: // COLUMNS
          return COLUMNS;
        case 9: // KEYS_ONLY
          return KEYS_ONLY;
        case 14: // CELL_LIMIT
          return CELL_LIMIT;
        case 10: // CELL_LIMIT_PER_FAMILY
          return CELL_LIMIT_PER_FAMILY;
        case 11: // ROW_REGEXP
          return ROW_REGEXP;
        case 12: // VALUE_REGEXP
          return VALUE_REGEXP;
        case 13: // SCAN_AND_FILTER_ROWS
          return SCAN_AND_FILTER_ROWS;
        case 15: // ROW_OFFSET
          return ROW_OFFSET;
        case 16: // CELL_OFFSET
          return CELL_OFFSET;
        case 17: // COLUMN_PREDICATES
          return COLUMN_PREDICATES;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __RETURN_DELETES_ISSET_ID = 0;
  private static final int __VERSIONS_ISSET_ID = 1;
  private static final int __ROW_LIMIT_ISSET_ID = 2;
  private static final int __START_TIME_ISSET_ID = 3;
  private static final int __END_TIME_ISSET_ID = 4;
  private static final int __KEYS_ONLY_ISSET_ID = 5;
  private static final int __CELL_LIMIT_ISSET_ID = 6;
  private static final int __CELL_LIMIT_PER_FAMILY_ISSET_ID = 7;
  private static final int __SCAN_AND_FILTER_ROWS_ISSET_ID = 8;
  private static final int __ROW_OFFSET_ISSET_ID = 9;
  private static final int __CELL_OFFSET_ISSET_ID = 10;
  private BitSet __isset_bit_vector = new BitSet(11);

  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.ROW_INTERVALS, new org.apache.thrift.meta_data.FieldMetaData("row_intervals", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, RowInterval.class))));
    tmpMap.put(_Fields.CELL_INTERVALS, new org.apache.thrift.meta_data.FieldMetaData("cell_intervals", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, CellInterval.class))));
    tmpMap.put(_Fields.RETURN_DELETES, new org.apache.thrift.meta_data.FieldMetaData("return_deletes", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.VERSIONS, new org.apache.thrift.meta_data.FieldMetaData("versions", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.ROW_LIMIT, new org.apache.thrift.meta_data.FieldMetaData("row_limit", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.START_TIME, new org.apache.thrift.meta_data.FieldMetaData("start_time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.END_TIME, new org.apache.thrift.meta_data.FieldMetaData("end_time", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.COLUMNS, new org.apache.thrift.meta_data.FieldMetaData("columns", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
    tmpMap.put(_Fields.KEYS_ONLY, new org.apache.thrift.meta_data.FieldMetaData("keys_only", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.CELL_LIMIT, new org.apache.thrift.meta_data.FieldMetaData("cell_limit", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CELL_LIMIT_PER_FAMILY, new org.apache.thrift.meta_data.FieldMetaData("cell_limit_per_family", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.ROW_REGEXP, new org.apache.thrift.meta_data.FieldMetaData("row_regexp", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.VALUE_REGEXP, new org.apache.thrift.meta_data.FieldMetaData("value_regexp", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.SCAN_AND_FILTER_ROWS, new org.apache.thrift.meta_data.FieldMetaData("scan_and_filter_rows", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.ROW_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("row_offset", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CELL_OFFSET, new org.apache.thrift.meta_data.FieldMetaData("cell_offset", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.COLUMN_PREDICATES, new org.apache.thrift.meta_data.FieldMetaData("column_predicates", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, ColumnPredicate.class))));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(ScanSpec.class, metaDataMap);
  }

  public ScanSpec() {
    this.return_deletes = false;

    this.versions = 0;

    this.row_limit = 0;

    this.keys_only = false;

    this.cell_limit = 0;

    this.cell_limit_per_family = 0;

    this.scan_and_filter_rows = false;

    this.row_offset = 0;

    this.cell_offset = 0;

  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public ScanSpec(ScanSpec other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    if (other.isSetRow_intervals()) {
      List<RowInterval> __this__row_intervals = new ArrayList<RowInterval>();
      for (RowInterval other_element : other.row_intervals) {
        __this__row_intervals.add(new RowInterval(other_element));
      }
      this.row_intervals = __this__row_intervals;
    }
    if (other.isSetCell_intervals()) {
      List<CellInterval> __this__cell_intervals = new ArrayList<CellInterval>();
      for (CellInterval other_element : other.cell_intervals) {
        __this__cell_intervals.add(new CellInterval(other_element));
      }
      this.cell_intervals = __this__cell_intervals;
    }
    this.return_deletes = other.return_deletes;
    this.versions = other.versions;
    this.row_limit = other.row_limit;
    this.start_time = other.start_time;
    this.end_time = other.end_time;
    if (other.isSetColumns()) {
      List<String> __this__columns = new ArrayList<String>();
      for (String other_element : other.columns) {
        __this__columns.add(other_element);
      }
      this.columns = __this__columns;
    }
    this.keys_only = other.keys_only;
    this.cell_limit = other.cell_limit;
    this.cell_limit_per_family = other.cell_limit_per_family;
    if (other.isSetRow_regexp()) {
      this.row_regexp = other.row_regexp;
    }
    if (other.isSetValue_regexp()) {
      this.value_regexp = other.value_regexp;
    }
    this.scan_and_filter_rows = other.scan_and_filter_rows;
    this.row_offset = other.row_offset;
    this.cell_offset = other.cell_offset;
    if (other.isSetColumn_predicates()) {
      List<ColumnPredicate> __this__column_predicates = new ArrayList<ColumnPredicate>();
      for (ColumnPredicate other_element : other.column_predicates) {
        __this__column_predicates.add(new ColumnPredicate(other_element));
      }
      this.column_predicates = __this__column_predicates;
    }
  }

  public ScanSpec deepCopy() {
    return new ScanSpec(this);
  }

  @Override
  public void clear() {
    this.row_intervals = null;
    this.cell_intervals = null;
    this.return_deletes = false;

    this.versions = 0;

    this.row_limit = 0;

    setStart_timeIsSet(false);
    this.start_time = 0;
    setEnd_timeIsSet(false);
    this.end_time = 0;
    this.columns = null;
    this.keys_only = false;

    this.cell_limit = 0;

    this.cell_limit_per_family = 0;

    this.row_regexp = null;
    this.value_regexp = null;
    this.scan_and_filter_rows = false;

    this.row_offset = 0;

    this.cell_offset = 0;

    this.column_predicates = null;
  }

  public int getRow_intervalsSize() {
    return (this.row_intervals == null) ? 0 : this.row_intervals.size();
  }

  public java.util.Iterator<RowInterval> getRow_intervalsIterator() {
    return (this.row_intervals == null) ? null : this.row_intervals.iterator();
  }

  public void addToRow_intervals(RowInterval elem) {
    if (this.row_intervals == null) {
      this.row_intervals = new ArrayList<RowInterval>();
    }
    this.row_intervals.add(elem);
  }

  public List<RowInterval> getRow_intervals() {
    return this.row_intervals;
  }

  public ScanSpec setRow_intervals(List<RowInterval> row_intervals) {
    this.row_intervals = row_intervals;
    return this;
  }

  public void unsetRow_intervals() {
    this.row_intervals = null;
  }

  /** Returns true if field row_intervals is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_intervals() {
    return this.row_intervals != null;
  }

  public void setRow_intervalsIsSet(boolean value) {
    if (!value) {
      this.row_intervals = null;
    }
  }

  public int getCell_intervalsSize() {
    return (this.cell_intervals == null) ? 0 : this.cell_intervals.size();
  }

  public java.util.Iterator<CellInterval> getCell_intervalsIterator() {
    return (this.cell_intervals == null) ? null : this.cell_intervals.iterator();
  }

  public void addToCell_intervals(CellInterval elem) {
    if (this.cell_intervals == null) {
      this.cell_intervals = new ArrayList<CellInterval>();
    }
    this.cell_intervals.add(elem);
  }

  public List<CellInterval> getCell_intervals() {
    return this.cell_intervals;
  }

  public ScanSpec setCell_intervals(List<CellInterval> cell_intervals) {
    this.cell_intervals = cell_intervals;
    return this;
  }

  public void unsetCell_intervals() {
    this.cell_intervals = null;
  }

  /** Returns true if field cell_intervals is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_intervals() {
    return this.cell_intervals != null;
  }

  public void setCell_intervalsIsSet(boolean value) {
    if (!value) {
      this.cell_intervals = null;
    }
  }

  public boolean isReturn_deletes() {
    return this.return_deletes;
  }

  public ScanSpec setReturn_deletes(boolean return_deletes) {
    this.return_deletes = return_deletes;
    setReturn_deletesIsSet(true);
    return this;
  }

  public void unsetReturn_deletes() {
    __isset_bit_vector.clear(__RETURN_DELETES_ISSET_ID);
  }

  /** Returns true if field return_deletes is set (has been assigned a value) and false otherwise */
  public boolean isSetReturn_deletes() {
    return __isset_bit_vector.get(__RETURN_DELETES_ISSET_ID);
  }

  public void setReturn_deletesIsSet(boolean value) {
    __isset_bit_vector.set(__RETURN_DELETES_ISSET_ID, value);
  }

  public int getVersions() {
    return this.versions;
  }

  public ScanSpec setVersions(int versions) {
    this.versions = versions;
    setVersionsIsSet(true);
    return this;
  }

  public void unsetVersions() {
    __isset_bit_vector.clear(__VERSIONS_ISSET_ID);
  }

  /** Returns true if field versions is set (has been assigned a value) and false otherwise */
  public boolean isSetVersions() {
    return __isset_bit_vector.get(__VERSIONS_ISSET_ID);
  }

  public void setVersionsIsSet(boolean value) {
    __isset_bit_vector.set(__VERSIONS_ISSET_ID, value);
  }

  public int getRow_limit() {
    return this.row_limit;
  }

  public ScanSpec setRow_limit(int row_limit) {
    this.row_limit = row_limit;
    setRow_limitIsSet(true);
    return this;
  }

  public void unsetRow_limit() {
    __isset_bit_vector.clear(__ROW_LIMIT_ISSET_ID);
  }

  /** Returns true if field row_limit is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_limit() {
    return __isset_bit_vector.get(__ROW_LIMIT_ISSET_ID);
  }

  public void setRow_limitIsSet(boolean value) {
    __isset_bit_vector.set(__ROW_LIMIT_ISSET_ID, value);
  }

  public long getStart_time() {
    return this.start_time;
  }

  public ScanSpec setStart_time(long start_time) {
    this.start_time = start_time;
    setStart_timeIsSet(true);
    return this;
  }

  public void unsetStart_time() {
    __isset_bit_vector.clear(__START_TIME_ISSET_ID);
  }

  /** Returns true if field start_time is set (has been assigned a value) and false otherwise */
  public boolean isSetStart_time() {
    return __isset_bit_vector.get(__START_TIME_ISSET_ID);
  }

  public void setStart_timeIsSet(boolean value) {
    __isset_bit_vector.set(__START_TIME_ISSET_ID, value);
  }

  public long getEnd_time() {
    return this.end_time;
  }

  public ScanSpec setEnd_time(long end_time) {
    this.end_time = end_time;
    setEnd_timeIsSet(true);
    return this;
  }

  public void unsetEnd_time() {
    __isset_bit_vector.clear(__END_TIME_ISSET_ID);
  }

  /** Returns true if field end_time is set (has been assigned a value) and false otherwise */
  public boolean isSetEnd_time() {
    return __isset_bit_vector.get(__END_TIME_ISSET_ID);
  }

  public void setEnd_timeIsSet(boolean value) {
    __isset_bit_vector.set(__END_TIME_ISSET_ID, value);
  }

  public int getColumnsSize() {
    return (this.columns == null) ? 0 : this.columns.size();
  }

  public java.util.Iterator<String> getColumnsIterator() {
    return (this.columns == null) ? null : this.columns.iterator();
  }

  public void addToColumns(String elem) {
    if (this.columns == null) {
      this.columns = new ArrayList<String>();
    }
    this.columns.add(elem);
  }

  public List<String> getColumns() {
    return this.columns;
  }

  public ScanSpec setColumns(List<String> columns) {
    this.columns = columns;
    return this;
  }

  public void unsetColumns() {
    this.columns = null;
  }

  /** Returns true if field columns is set (has been assigned a value) and false otherwise */
  public boolean isSetColumns() {
    return this.columns != null;
  }

  public void setColumnsIsSet(boolean value) {
    if (!value) {
      this.columns = null;
    }
  }

  public boolean isKeys_only() {
    return this.keys_only;
  }

  public ScanSpec setKeys_only(boolean keys_only) {
    this.keys_only = keys_only;
    setKeys_onlyIsSet(true);
    return this;
  }

  public void unsetKeys_only() {
    __isset_bit_vector.clear(__KEYS_ONLY_ISSET_ID);
  }

  /** Returns true if field keys_only is set (has been assigned a value) and false otherwise */
  public boolean isSetKeys_only() {
    return __isset_bit_vector.get(__KEYS_ONLY_ISSET_ID);
  }

  public void setKeys_onlyIsSet(boolean value) {
    __isset_bit_vector.set(__KEYS_ONLY_ISSET_ID, value);
  }

  public int getCell_limit() {
    return this.cell_limit;
  }

  public ScanSpec setCell_limit(int cell_limit) {
    this.cell_limit = cell_limit;
    setCell_limitIsSet(true);
    return this;
  }

  public void unsetCell_limit() {
    __isset_bit_vector.clear(__CELL_LIMIT_ISSET_ID);
  }

  /** Returns true if field cell_limit is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_limit() {
    return __isset_bit_vector.get(__CELL_LIMIT_ISSET_ID);
  }

  public void setCell_limitIsSet(boolean value) {
    __isset_bit_vector.set(__CELL_LIMIT_ISSET_ID, value);
  }

  public int getCell_limit_per_family() {
    return this.cell_limit_per_family;
  }

  public ScanSpec setCell_limit_per_family(int cell_limit_per_family) {
    this.cell_limit_per_family = cell_limit_per_family;
    setCell_limit_per_familyIsSet(true);
    return this;
  }

  public void unsetCell_limit_per_family() {
    __isset_bit_vector.clear(__CELL_LIMIT_PER_FAMILY_ISSET_ID);
  }

  /** Returns true if field cell_limit_per_family is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_limit_per_family() {
    return __isset_bit_vector.get(__CELL_LIMIT_PER_FAMILY_ISSET_ID);
  }

  public void setCell_limit_per_familyIsSet(boolean value) {
    __isset_bit_vector.set(__CELL_LIMIT_PER_FAMILY_ISSET_ID, value);
  }

  public String getRow_regexp() {
    return this.row_regexp;
  }

  public ScanSpec setRow_regexp(String row_regexp) {
    this.row_regexp = row_regexp;
    return this;
  }

  public void unsetRow_regexp() {
    this.row_regexp = null;
  }

  /** Returns true if field row_regexp is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_regexp() {
    return this.row_regexp != null;
  }

  public void setRow_regexpIsSet(boolean value) {
    if (!value) {
      this.row_regexp = null;
    }
  }

  public String getValue_regexp() {
    return this.value_regexp;
  }

  public ScanSpec setValue_regexp(String value_regexp) {
    this.value_regexp = value_regexp;
    return this;
  }

  public void unsetValue_regexp() {
    this.value_regexp = null;
  }

  /** Returns true if field value_regexp is set (has been assigned a value) and false otherwise */
  public boolean isSetValue_regexp() {
    return this.value_regexp != null;
  }

  public void setValue_regexpIsSet(boolean value) {
    if (!value) {
      this.value_regexp = null;
    }
  }

  public boolean isScan_and_filter_rows() {
    return this.scan_and_filter_rows;
  }

  public ScanSpec setScan_and_filter_rows(boolean scan_and_filter_rows) {
    this.scan_and_filter_rows = scan_and_filter_rows;
    setScan_and_filter_rowsIsSet(true);
    return this;
  }

  public void unsetScan_and_filter_rows() {
    __isset_bit_vector.clear(__SCAN_AND_FILTER_ROWS_ISSET_ID);
  }

  /** Returns true if field scan_and_filter_rows is set (has been assigned a value) and false otherwise */
  public boolean isSetScan_and_filter_rows() {
    return __isset_bit_vector.get(__SCAN_AND_FILTER_ROWS_ISSET_ID);
  }

  public void setScan_and_filter_rowsIsSet(boolean value) {
    __isset_bit_vector.set(__SCAN_AND_FILTER_ROWS_ISSET_ID, value);
  }

  public int getRow_offset() {
    return this.row_offset;
  }

  public ScanSpec setRow_offset(int row_offset) {
    this.row_offset = row_offset;
    setRow_offsetIsSet(true);
    return this;
  }

  public void unsetRow_offset() {
    __isset_bit_vector.clear(__ROW_OFFSET_ISSET_ID);
  }

  /** Returns true if field row_offset is set (has been assigned a value) and false otherwise */
  public boolean isSetRow_offset() {
    return __isset_bit_vector.get(__ROW_OFFSET_ISSET_ID);
  }

  public void setRow_offsetIsSet(boolean value) {
    __isset_bit_vector.set(__ROW_OFFSET_ISSET_ID, value);
  }

  public int getCell_offset() {
    return this.cell_offset;
  }

  public ScanSpec setCell_offset(int cell_offset) {
    this.cell_offset = cell_offset;
    setCell_offsetIsSet(true);
    return this;
  }

  public void unsetCell_offset() {
    __isset_bit_vector.clear(__CELL_OFFSET_ISSET_ID);
  }

  /** Returns true if field cell_offset is set (has been assigned a value) and false otherwise */
  public boolean isSetCell_offset() {
    return __isset_bit_vector.get(__CELL_OFFSET_ISSET_ID);
  }

  public void setCell_offsetIsSet(boolean value) {
    __isset_bit_vector.set(__CELL_OFFSET_ISSET_ID, value);
  }

  public int getColumn_predicatesSize() {
    return (this.column_predicates == null) ? 0 : this.column_predicates.size();
  }

  public java.util.Iterator<ColumnPredicate> getColumn_predicatesIterator() {
    return (this.column_predicates == null) ? null : this.column_predicates.iterator();
  }

  public void addToColumn_predicates(ColumnPredicate elem) {
    if (this.column_predicates == null) {
      this.column_predicates = new ArrayList<ColumnPredicate>();
    }
    this.column_predicates.add(elem);
  }

  public List<ColumnPredicate> getColumn_predicates() {
    return this.column_predicates;
  }

  public ScanSpec setColumn_predicates(List<ColumnPredicate> column_predicates) {
    this.column_predicates = column_predicates;
    return this;
  }

  public void unsetColumn_predicates() {
    this.column_predicates = null;
  }

  /** Returns true if field column_predicates is set (has been assigned a value) and false otherwise */
  public boolean isSetColumn_predicates() {
    return this.column_predicates != null;
  }

  public void setColumn_predicatesIsSet(boolean value) {
    if (!value) {
      this.column_predicates = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case ROW_INTERVALS:
      if (value == null) {
        unsetRow_intervals();
      } else {
        setRow_intervals((List<RowInterval>)value);
      }
      break;

    case CELL_INTERVALS:
      if (value == null) {
        unsetCell_intervals();
      } else {
        setCell_intervals((List<CellInterval>)value);
      }
      break;

    case RETURN_DELETES:
      if (value == null) {
        unsetReturn_deletes();
      } else {
        setReturn_deletes((Boolean)value);
      }
      break;

    case VERSIONS:
      if (value == null) {
        unsetVersions();
      } else {
        setVersions((Integer)value);
      }
      break;

    case ROW_LIMIT:
      if (value == null) {
        unsetRow_limit();
      } else {
        setRow_limit((Integer)value);
      }
      break;

    case START_TIME:
      if (value == null) {
        unsetStart_time();
      } else {
        setStart_time((Long)value);
      }
      break;

    case END_TIME:
      if (value == null) {
        unsetEnd_time();
      } else {
        setEnd_time((Long)value);
      }
      break;

    case COLUMNS:
      if (value == null) {
        unsetColumns();
      } else {
        setColumns((List<String>)value);
      }
      break;

    case KEYS_ONLY:
      if (value == null) {
        unsetKeys_only();
      } else {
        setKeys_only((Boolean)value);
      }
      break;

    case CELL_LIMIT:
      if (value == null) {
        unsetCell_limit();
      } else {
        setCell_limit((Integer)value);
      }
      break;

    case CELL_LIMIT_PER_FAMILY:
      if (value == null) {
        unsetCell_limit_per_family();
      } else {
        setCell_limit_per_family((Integer)value);
      }
      break;

    case ROW_REGEXP:
      if (value == null) {
        unsetRow_regexp();
      } else {
        setRow_regexp((String)value);
      }
      break;

    case VALUE_REGEXP:
      if (value == null) {
        unsetValue_regexp();
      } else {
        setValue_regexp((String)value);
      }
      break;

    case SCAN_AND_FILTER_ROWS:
      if (value == null) {
        unsetScan_and_filter_rows();
      } else {
        setScan_and_filter_rows((Boolean)value);
      }
      break;

    case ROW_OFFSET:
      if (value == null) {
        unsetRow_offset();
      } else {
        setRow_offset((Integer)value);
      }
      break;

    case CELL_OFFSET:
      if (value == null) {
        unsetCell_offset();
      } else {
        setCell_offset((Integer)value);
      }
      break;

    case COLUMN_PREDICATES:
      if (value == null) {
        unsetColumn_predicates();
      } else {
        setColumn_predicates((List<ColumnPredicate>)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case ROW_INTERVALS:
      return getRow_intervals();

    case CELL_INTERVALS:
      return getCell_intervals();

    case RETURN_DELETES:
      return Boolean.valueOf(isReturn_deletes());

    case VERSIONS:
      return Integer.valueOf(getVersions());

    case ROW_LIMIT:
      return Integer.valueOf(getRow_limit());

    case START_TIME:
      return Long.valueOf(getStart_time());

    case END_TIME:
      return Long.valueOf(getEnd_time());

    case COLUMNS:
      return getColumns();

    case KEYS_ONLY:
      return Boolean.valueOf(isKeys_only());

    case CELL_LIMIT:
      return Integer.valueOf(getCell_limit());

    case CELL_LIMIT_PER_FAMILY:
      return Integer.valueOf(getCell_limit_per_family());

    case ROW_REGEXP:
      return getRow_regexp();

    case VALUE_REGEXP:
      return getValue_regexp();

    case SCAN_AND_FILTER_ROWS:
      return Boolean.valueOf(isScan_and_filter_rows());

    case ROW_OFFSET:
      return Integer.valueOf(getRow_offset());

    case CELL_OFFSET:
      return Integer.valueOf(getCell_offset());

    case COLUMN_PREDICATES:
      return getColumn_predicates();

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case ROW_INTERVALS:
      return isSetRow_intervals();
    case CELL_INTERVALS:
      return isSetCell_intervals();
    case RETURN_DELETES:
      return isSetReturn_deletes();
    case VERSIONS:
      return isSetVersions();
    case ROW_LIMIT:
      return isSetRow_limit();
    case START_TIME:
      return isSetStart_time();
    case END_TIME:
      return isSetEnd_time();
    case COLUMNS:
      return isSetColumns();
    case KEYS_ONLY:
      return isSetKeys_only();
    case CELL_LIMIT:
      return isSetCell_limit();
    case CELL_LIMIT_PER_FAMILY:
      return isSetCell_limit_per_family();
    case ROW_REGEXP:
      return isSetRow_regexp();
    case VALUE_REGEXP:
      return isSetValue_regexp();
    case SCAN_AND_FILTER_ROWS:
      return isSetScan_and_filter_rows();
    case ROW_OFFSET:
      return isSetRow_offset();
    case CELL_OFFSET:
      return isSetCell_offset();
    case COLUMN_PREDICATES:
      return isSetColumn_predicates();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof ScanSpec)
      return this.equals((ScanSpec)that);
    return false;
  }

  public boolean equals(ScanSpec that) {
    if (that == null)
      return false;

    boolean this_present_row_intervals = true && this.isSetRow_intervals();
    boolean that_present_row_intervals = true && that.isSetRow_intervals();
    if (this_present_row_intervals || that_present_row_intervals) {
      if (!(this_present_row_intervals && that_present_row_intervals))
        return false;
      if (!this.row_intervals.equals(that.row_intervals))
        return false;
    }

    boolean this_present_cell_intervals = true && this.isSetCell_intervals();
    boolean that_present_cell_intervals = true && that.isSetCell_intervals();
    if (this_present_cell_intervals || that_present_cell_intervals) {
      if (!(this_present_cell_intervals && that_present_cell_intervals))
        return false;
      if (!this.cell_intervals.equals(that.cell_intervals))
        return false;
    }

    boolean this_present_return_deletes = true && this.isSetReturn_deletes();
    boolean that_present_return_deletes = true && that.isSetReturn_deletes();
    if (this_present_return_deletes || that_present_return_deletes) {
      if (!(this_present_return_deletes && that_present_return_deletes))
        return false;
      if (this.return_deletes != that.return_deletes)
        return false;
    }

    boolean this_present_versions = true && this.isSetVersions();
    boolean that_present_versions = true && that.isSetVersions();
    if (this_present_versions || that_present_versions) {
      if (!(this_present_versions && that_present_versions))
        return false;
      if (this.versions != that.versions)
        return false;
    }

    boolean this_present_row_limit = true && this.isSetRow_limit();
    boolean that_present_row_limit = true && that.isSetRow_limit();
    if (this_present_row_limit || that_present_row_limit) {
      if (!(this_present_row_limit && that_present_row_limit))
        return false;
      if (this.row_limit != that.row_limit)
        return false;
    }

    boolean this_present_start_time = true && this.isSetStart_time();
    boolean that_present_start_time = true && that.isSetStart_time();
    if (this_present_start_time || that_present_start_time) {
      if (!(this_present_start_time && that_present_start_time))
        return false;
      if (this.start_time != that.start_time)
        return false;
    }

    boolean this_present_end_time = true && this.isSetEnd_time();
    boolean that_present_end_time = true && that.isSetEnd_time();
    if (this_present_end_time || that_present_end_time) {
      if (!(this_present_end_time && that_present_end_time))
        return false;
      if (this.end_time != that.end_time)
        return false;
    }

    boolean this_present_columns = true && this.isSetColumns();
    boolean that_present_columns = true && that.isSetColumns();
    if (this_present_columns || that_present_columns) {
      if (!(this_present_columns && that_present_columns))
        return false;
      if (!this.columns.equals(that.columns))
        return false;
    }

    boolean this_present_keys_only = true && this.isSetKeys_only();
    boolean that_present_keys_only = true && that.isSetKeys_only();
    if (this_present_keys_only || that_present_keys_only) {
      if (!(this_present_keys_only && that_present_keys_only))
        return false;
      if (this.keys_only != that.keys_only)
        return false;
    }

    boolean this_present_cell_limit = true && this.isSetCell_limit();
    boolean that_present_cell_limit = true && that.isSetCell_limit();
    if (this_present_cell_limit || that_present_cell_limit) {
      if (!(this_present_cell_limit && that_present_cell_limit))
        return false;
      if (this.cell_limit != that.cell_limit)
        return false;
    }

    boolean this_present_cell_limit_per_family = true && this.isSetCell_limit_per_family();
    boolean that_present_cell_limit_per_family = true && that.isSetCell_limit_per_family();
    if (this_present_cell_limit_per_family || that_present_cell_limit_per_family) {
      if (!(this_present_cell_limit_per_family && that_present_cell_limit_per_family))
        return false;
      if (this.cell_limit_per_family != that.cell_limit_per_family)
        return false;
    }

    boolean this_present_row_regexp = true && this.isSetRow_regexp();
    boolean that_present_row_regexp = true && that.isSetRow_regexp();
    if (this_present_row_regexp || that_present_row_regexp) {
      if (!(this_present_row_regexp && that_present_row_regexp))
        return false;
      if (!this.row_regexp.equals(that.row_regexp))
        return false;
    }

    boolean this_present_value_regexp = true && this.isSetValue_regexp();
    boolean that_present_value_regexp = true && that.isSetValue_regexp();
    if (this_present_value_regexp || that_present_value_regexp) {
      if (!(this_present_value_regexp && that_present_value_regexp))
        return false;
      if (!this.value_regexp.equals(that.value_regexp))
        return false;
    }

    boolean this_present_scan_and_filter_rows = true && this.isSetScan_and_filter_rows();
    boolean that_present_scan_and_filter_rows = true && that.isSetScan_and_filter_rows();
    if (this_present_scan_and_filter_rows || that_present_scan_and_filter_rows) {
      if (!(this_present_scan_and_filter_rows && that_present_scan_and_filter_rows))
        return false;
      if (this.scan_and_filter_rows != that.scan_and_filter_rows)
        return false;
    }

    boolean this_present_row_offset = true && this.isSetRow_offset();
    boolean that_present_row_offset = true && that.isSetRow_offset();
    if (this_present_row_offset || that_present_row_offset) {
      if (!(this_present_row_offset && that_present_row_offset))
        return false;
      if (this.row_offset != that.row_offset)
        return false;
    }

    boolean this_present_cell_offset = true && this.isSetCell_offset();
    boolean that_present_cell_offset = true && that.isSetCell_offset();
    if (this_present_cell_offset || that_present_cell_offset) {
      if (!(this_present_cell_offset && that_present_cell_offset))
        return false;
      if (this.cell_offset != that.cell_offset)
        return false;
    }

    boolean this_present_column_predicates = true && this.isSetColumn_predicates();
    boolean that_present_column_predicates = true && that.isSetColumn_predicates();
    if (this_present_column_predicates || that_present_column_predicates) {
      if (!(this_present_column_predicates && that_present_column_predicates))
        return false;
      if (!this.column_predicates.equals(that.column_predicates))
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public int compareTo(ScanSpec other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    ScanSpec typedOther = (ScanSpec)other;

    lastComparison = Boolean.valueOf(isSetRow_intervals()).compareTo(typedOther.isSetRow_intervals());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_intervals()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_intervals, typedOther.row_intervals);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_intervals()).compareTo(typedOther.isSetCell_intervals());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_intervals()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_intervals, typedOther.cell_intervals);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetReturn_deletes()).compareTo(typedOther.isSetReturn_deletes());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetReturn_deletes()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.return_deletes, typedOther.return_deletes);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetVersions()).compareTo(typedOther.isSetVersions());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetVersions()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.versions, typedOther.versions);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_limit()).compareTo(typedOther.isSetRow_limit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_limit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_limit, typedOther.row_limit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetStart_time()).compareTo(typedOther.isSetStart_time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetStart_time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.start_time, typedOther.start_time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetEnd_time()).compareTo(typedOther.isSetEnd_time());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetEnd_time()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.end_time, typedOther.end_time);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumns()).compareTo(typedOther.isSetColumns());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumns()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columns, typedOther.columns);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetKeys_only()).compareTo(typedOther.isSetKeys_only());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetKeys_only()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.keys_only, typedOther.keys_only);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_limit()).compareTo(typedOther.isSetCell_limit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_limit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_limit, typedOther.cell_limit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_limit_per_family()).compareTo(typedOther.isSetCell_limit_per_family());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_limit_per_family()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_limit_per_family, typedOther.cell_limit_per_family);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_regexp()).compareTo(typedOther.isSetRow_regexp());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_regexp()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_regexp, typedOther.row_regexp);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetValue_regexp()).compareTo(typedOther.isSetValue_regexp());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetValue_regexp()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.value_regexp, typedOther.value_regexp);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetScan_and_filter_rows()).compareTo(typedOther.isSetScan_and_filter_rows());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetScan_and_filter_rows()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.scan_and_filter_rows, typedOther.scan_and_filter_rows);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRow_offset()).compareTo(typedOther.isSetRow_offset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRow_offset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.row_offset, typedOther.row_offset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCell_offset()).compareTo(typedOther.isSetCell_offset());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCell_offset()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cell_offset, typedOther.cell_offset);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumn_predicates()).compareTo(typedOther.isSetColumn_predicates());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumn_predicates()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.column_predicates, typedOther.column_predicates);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // ROW_INTERVALS
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list0 = iprot.readListBegin();
              this.row_intervals = new ArrayList<RowInterval>(_list0.size);
              for (int _i1 = 0; _i1 < _list0.size; ++_i1)
              {
                RowInterval _elem2; // required
                _elem2 = new RowInterval();
                _elem2.read(iprot);
                this.row_intervals.add(_elem2);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // CELL_INTERVALS
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list3 = iprot.readListBegin();
              this.cell_intervals = new ArrayList<CellInterval>(_list3.size);
              for (int _i4 = 0; _i4 < _list3.size; ++_i4)
              {
                CellInterval _elem5; // required
                _elem5 = new CellInterval();
                _elem5.read(iprot);
                this.cell_intervals.add(_elem5);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // RETURN_DELETES
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.return_deletes = iprot.readBool();
            setReturn_deletesIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 4: // VERSIONS
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.versions = iprot.readI32();
            setVersionsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // ROW_LIMIT
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_limit = iprot.readI32();
            setRow_limitIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // START_TIME
          if (field.type == org.apache.thrift.protocol.TType.I64) {
            this.start_time = iprot.readI64();
            setStart_timeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 7: // END_TIME
          if (field.type == org.apache.thrift.protocol.TType.I64) {
            this.end_time = iprot.readI64();
            setEnd_timeIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 8: // COLUMNS
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list6 = iprot.readListBegin();
              this.columns = new ArrayList<String>(_list6.size);
              for (int _i7 = 0; _i7 < _list6.size; ++_i7)
              {
                String _elem8; // required
                _elem8 = iprot.readString();
                this.columns.add(_elem8);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 9: // KEYS_ONLY
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.keys_only = iprot.readBool();
            setKeys_onlyIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 14: // CELL_LIMIT
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.cell_limit = iprot.readI32();
            setCell_limitIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 10: // CELL_LIMIT_PER_FAMILY
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.cell_limit_per_family = iprot.readI32();
            setCell_limit_per_familyIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 11: // ROW_REGEXP
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.row_regexp = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 12: // VALUE_REGEXP
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.value_regexp = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 13: // SCAN_AND_FILTER_ROWS
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.scan_and_filter_rows = iprot.readBool();
            setScan_and_filter_rowsIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 15: // ROW_OFFSET
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.row_offset = iprot.readI32();
            setRow_offsetIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 16: // CELL_OFFSET
          if (field.type == org.apache.thrift.protocol.TType.I32) {
            this.cell_offset = iprot.readI32();
            setCell_offsetIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 17: // COLUMN_PREDICATES
          if (field.type == org.apache.thrift.protocol.TType.LIST) {
            {
              org.apache.thrift.protocol.TList _list9 = iprot.readListBegin();
              this.column_predicates = new ArrayList<ColumnPredicate>(_list9.size);
              for (int _i10 = 0; _i10 < _list9.size; ++_i10)
              {
                ColumnPredicate _elem11; // required
                _elem11 = new ColumnPredicate();
                _elem11.read(iprot);
                this.column_predicates.add(_elem11);
              }
              iprot.readListEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.row_intervals != null) {
      if (isSetRow_intervals()) {
        oprot.writeFieldBegin(ROW_INTERVALS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.row_intervals.size()));
          for (RowInterval _iter12 : this.row_intervals)
          {
            _iter12.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (this.cell_intervals != null) {
      if (isSetCell_intervals()) {
        oprot.writeFieldBegin(CELL_INTERVALS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.cell_intervals.size()));
          for (CellInterval _iter13 : this.cell_intervals)
          {
            _iter13.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetReturn_deletes()) {
      oprot.writeFieldBegin(RETURN_DELETES_FIELD_DESC);
      oprot.writeBool(this.return_deletes);
      oprot.writeFieldEnd();
    }
    if (isSetVersions()) {
      oprot.writeFieldBegin(VERSIONS_FIELD_DESC);
      oprot.writeI32(this.versions);
      oprot.writeFieldEnd();
    }
    if (isSetRow_limit()) {
      oprot.writeFieldBegin(ROW_LIMIT_FIELD_DESC);
      oprot.writeI32(this.row_limit);
      oprot.writeFieldEnd();
    }
    if (isSetStart_time()) {
      oprot.writeFieldBegin(START_TIME_FIELD_DESC);
      oprot.writeI64(this.start_time);
      oprot.writeFieldEnd();
    }
    if (isSetEnd_time()) {
      oprot.writeFieldBegin(END_TIME_FIELD_DESC);
      oprot.writeI64(this.end_time);
      oprot.writeFieldEnd();
    }
    if (this.columns != null) {
      if (isSetColumns()) {
        oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, this.columns.size()));
          for (String _iter14 : this.columns)
          {
            oprot.writeString(_iter14);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    if (isSetKeys_only()) {
      oprot.writeFieldBegin(KEYS_ONLY_FIELD_DESC);
      oprot.writeBool(this.keys_only);
      oprot.writeFieldEnd();
    }
    if (isSetCell_limit_per_family()) {
      oprot.writeFieldBegin(CELL_LIMIT_PER_FAMILY_FIELD_DESC);
      oprot.writeI32(this.cell_limit_per_family);
      oprot.writeFieldEnd();
    }
    if (this.row_regexp != null) {
      if (isSetRow_regexp()) {
        oprot.writeFieldBegin(ROW_REGEXP_FIELD_DESC);
        oprot.writeString(this.row_regexp);
        oprot.writeFieldEnd();
      }
    }
    if (this.value_regexp != null) {
      if (isSetValue_regexp()) {
        oprot.writeFieldBegin(VALUE_REGEXP_FIELD_DESC);
        oprot.writeString(this.value_regexp);
        oprot.writeFieldEnd();
      }
    }
    if (isSetScan_and_filter_rows()) {
      oprot.writeFieldBegin(SCAN_AND_FILTER_ROWS_FIELD_DESC);
      oprot.writeBool(this.scan_and_filter_rows);
      oprot.writeFieldEnd();
    }
    if (isSetCell_limit()) {
      oprot.writeFieldBegin(CELL_LIMIT_FIELD_DESC);
      oprot.writeI32(this.cell_limit);
      oprot.writeFieldEnd();
    }
    if (isSetRow_offset()) {
      oprot.writeFieldBegin(ROW_OFFSET_FIELD_DESC);
      oprot.writeI32(this.row_offset);
      oprot.writeFieldEnd();
    }
    if (isSetCell_offset()) {
      oprot.writeFieldBegin(CELL_OFFSET_FIELD_DESC);
      oprot.writeI32(this.cell_offset);
      oprot.writeFieldEnd();
    }
    if (this.column_predicates != null) {
      if (isSetColumn_predicates()) {
        oprot.writeFieldBegin(COLUMN_PREDICATES_FIELD_DESC);
        {
          oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRUCT, this.column_predicates.size()));
          for (ColumnPredicate _iter15 : this.column_predicates)
          {
            _iter15.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("ScanSpec(");
    boolean first = true;

    if (isSetRow_intervals()) {
      sb.append("row_intervals:");
      if (this.row_intervals == null) {
        sb.append("null");
      } else {
        sb.append(this.row_intervals);
      }
      first = false;
    }
    if (isSetCell_intervals()) {
      if (!first) sb.append(", ");
      sb.append("cell_intervals:");
      if (this.cell_intervals == null) {
        sb.append("null");
      } else {
        sb.append(this.cell_intervals);
      }
      first = false;
    }
    if (isSetReturn_deletes()) {
      if (!first) sb.append(", ");
      sb.append("return_deletes:");
      sb.append(this.return_deletes);
      first = false;
    }
    if (isSetVersions()) {
      if (!first) sb.append(", ");
      sb.append("versions:");
      sb.append(this.versions);
      first = false;
    }
    if (isSetRow_limit()) {
      if (!first) sb.append(", ");
      sb.append("row_limit:");
      sb.append(this.row_limit);
      first = false;
    }
    if (isSetStart_time()) {
      if (!first) sb.append(", ");
      sb.append("start_time:");
      sb.append(this.start_time);
      first = false;
    }
    if (isSetEnd_time()) {
      if (!first) sb.append(", ");
      sb.append("end_time:");
      sb.append(this.end_time);
      first = false;
    }
    if (isSetColumns()) {
      if (!first) sb.append(", ");
      sb.append("columns:");
      if (this.columns == null) {
        sb.append("null");
      } else {
        sb.append(this.columns);
      }
      first = false;
    }
    if (isSetKeys_only()) {
      if (!first) sb.append(", ");
      sb.append("keys_only:");
      sb.append(this.keys_only);
      first = false;
    }
    if (isSetCell_limit()) {
      if (!first) sb.append(", ");
      sb.append("cell_limit:");
      sb.append(this.cell_limit);
      first = false;
    }
    if (isSetCell_limit_per_family()) {
      if (!first) sb.append(", ");
      sb.append("cell_limit_per_family:");
      sb.append(this.cell_limit_per_family);
      first = false;
    }
    if (isSetRow_regexp()) {
      if (!first) sb.append(", ");
      sb.append("row_regexp:");
      if (this.row_regexp == null) {
        sb.append("null");
      } else {
        sb.append(this.row_regexp);
      }
      first = false;
    }
    if (isSetValue_regexp()) {
      if (!first) sb.append(", ");
      sb.append("value_regexp:");
      if (this.value_regexp == null) {
        sb.append("null");
      } else {
        sb.append(this.value_regexp);
      }
      first = false;
    }
    if (isSetScan_and_filter_rows()) {
      if (!first) sb.append(", ");
      sb.append("scan_and_filter_rows:");
      sb.append(this.scan_and_filter_rows);
      first = false;
    }
    if (isSetRow_offset()) {
      if (!first) sb.append(", ");
      sb.append("row_offset:");
      sb.append(this.row_offset);
      first = false;
    }
    if (isSetCell_offset()) {
      if (!first) sb.append(", ");
      sb.append("cell_offset:");
      sb.append(this.cell_offset);
      first = false;
    }
    if (isSetColumn_predicates()) {
      if (!first) sb.append(", ");
      sb.append("column_predicates:");
      if (this.column_predicates == null) {
        sb.append("null");
      } else {
        sb.append(this.column_predicates);
      }
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bit_vector = new BitSet(1);
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

}

